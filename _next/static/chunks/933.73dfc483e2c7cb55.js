"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[933],{22933:function(i,e,t){t.r(e),t.d(e,{OpenloginAdapter:function(){return g},getOpenloginDefaultOptions:function(){return l}});var n=t(3388),o=t(4942),r=t(16716),s=t(17328),a=t(72378),h=t.n(a);let l=()=>({adapterSettings:{network:n.dr.MAINNET,clientId:"",uxMode:n.$e.POPUP},loginSettings:{}});function c(i,e){var t=Object.keys(i);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(i);e&&(n=n.filter(function(e){return Object.getOwnPropertyDescriptor(i,e).enumerable})),t.push.apply(t,n)}return t}function p(i){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?c(Object(t),!0).forEach(function(e){(0,o.Z)(i,e,t[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(i,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach(function(e){Object.defineProperty(i,e,Object.getOwnPropertyDescriptor(t,e))})}return i}class g extends r.J5{get chainConfigProxy(){return this.chainConfig?p({},this.chainConfig):null}get provider(){var i;return(null===(i=this.privKeyProvider)||void 0===i?void 0:i.provider)||null}set provider(i){throw Error("Not implemented")}async init(i){if(super.checkInitializationRequirements(),!this.clientId)throw r.Ty.invalidParams("clientId is required before openlogin's initialization");if(!this.openloginOptions)throw r.Ty.invalidParams("openloginOptions is required before openlogin's initialization");let e=!1;if(this.openloginOptions.uxMode===n.$e.REDIRECT||this.openloginOptions.uxMode===n.$e.SESSIONLESS_REDIRECT){let i=(0,n.Gv)();Object.keys(i).length>0&&i._pid&&(e=!0)}this.openloginOptions=p(p({},this.openloginOptions),{},{replaceUrlOnRedirect:e}),this.openloginInstance=new n.ZP(p(p({},this.openloginOptions),{},{clientId:this.clientId,network:this.openloginOptions.network||this.web3AuthNetwork||n.dr.MAINNET})),r.cM.debug("initializing openlogin adapter init"),await this.openloginInstance.init(),this.status=r.MP.READY,this.emit(r.n2.READY,r.rW.OPENLOGIN);try{r.cM.debug("initializing openlogin adapter");let t=this._getFinalPrivKey();t&&(i.autoConnect||e)&&(this.rehydrated=!0,await this.connect())}catch(i){r.cM.error("Failed to connect with cached openlogin provider",i),this.emit("ERRORED",i)}}async connect(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};super.checkConnectionRequirements(),this.status=r.MP.CONNECTING,this.emit(r.n2.CONNECTING,p(p({},i),{},{adapter:r.rW.OPENLOGIN}));try{return await this.connectWithProvider(i),this.provider}catch(i){if(r.cM.error("Failed to connect with openlogin provider",i),this.status=r.MP.READY,this.emit(r.n2.ERRORED,i),null!=i&&i.message.includes("user closed popup"))throw r.RM.popupClosed();if(i instanceof r.up)throw i;throw r.RM.connectionError("Failed to login with openlogin")}}async disconnect(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");await this.openloginInstance.logout(),i.cleanup?(this.status=r.MP.NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=r.MP.READY,this.rehydrated=!1,this.emit(r.n2.DISCONNECTED)}async authenticateUser(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet, Please login/connect first");let i=await this.getUserInfo();return{idToken:i.idToken}}async getUserInfo(){if(this.status!==r.MP.CONNECTED)throw r.RM.notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");let i=await this.openloginInstance.getUserInfo();return i}setAdapterSettings(i){super.setAdapterSettings(i);let e=l();r.cM.info("setting adapter settings",i),this.openloginOptions=p(p(p({},e.adapterSettings),this.openloginOptions),i),i.web3AuthNetwork&&(this.openloginOptions.network=i.web3AuthNetwork),void 0!==i.useCoreKitKey&&(this.openloginOptions.useCoreKitKey=i.useCoreKitKey)}async addChain(i){var e;let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkAddChainRequirements(t),null===(e=this.privKeyProvider)||void 0===e||e.addChain(i),this.addChainConfig(i)}async switchChain(i){var e;let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.checkSwitchChainRequirements(i,t),await (null===(e=this.privKeyProvider)||void 0===e?void 0:e.switchChain(i)),this.setAdapterSettings({chainConfig:this.getChainConfig(i.chainId)})}_getFinalPrivKey(){var i;if(!this.openloginInstance)return"";let e=this.openloginInstance.privKey;if(null!==(i=this.openloginOptions)&&void 0!==i&&i.useCoreKitKey){if(!this.openloginInstance.coreKitKey)throw r.RM.coreKitKeyNotFound();e=this.openloginInstance.coreKitKey}return e}async connectWithProvider(){var i,e;let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{loginProvider:""};if(!this.chainConfig)throw r.Ty.invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw r.Ty.notReady("openloginInstance is not ready");if(this.currentChainNamespace===r.EN.SOLANA){let{SolanaPrivateKeyProvider:i}=await Promise.all([t.e(766),t.e(108),t.e(285),t.e(992)]).then(t.bind(t,30142));this.privKeyProvider=new i({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===r.EN.EIP155){let{EthereumPrivateKeyProvider:i}=await Promise.all([t.e(453),t.e(995)]).then(t.bind(t,48453));this.privKeyProvider=new i({config:{chainConfig:this.chainConfig}})}else if(this.currentChainNamespace===r.EN.OTHER)this.privKeyProvider=new s.FL;else throw Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));let a=this._getFinalPrivKey();if(!a||null!==(i=o.extraLoginOptions)&&void 0!==i&&i.id_token){if(this.loginSettings.curve||(this.loginSettings.curve=this.currentChainNamespace===r.EN.SOLANA?n.x7.ED25519:n.x7.SECP256K1),!o.loginProvider&&!this.loginSettings.loginProvider)throw r.Ty.invalidParams("loginProvider is required for login");await this.openloginInstance.login(h()(this.loginSettings,o,{extraLoginOptions:p(p({},o.extraLoginOptions||{}),{},{login_hint:o.login_hint||(null===(e=o.extraLoginOptions)||void 0===e?void 0:e.login_hint)})}))}let l=this._getFinalPrivKey();if(l){if(this.currentChainNamespace===r.EN.SOLANA){let{getED25519Key:i}=await Promise.all([t.e(108),t.e(418)]).then(t.bind(t,33946));l=i(l).sk.toString("hex")}await this.privKeyProvider.setupProvider(l),this.status=r.MP.CONNECTED,this.emit(r.n2.CONNECTED,{adapter:r.rW.OPENLOGIN,reconnected:this.rehydrated})}}constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(i),(0,o.Z)(this,"name",r.rW.OPENLOGIN),(0,o.Z)(this,"adapterNamespace",r.yk.MULTICHAIN),(0,o.Z)(this,"type",r.hN.IN_APP),(0,o.Z)(this,"openloginInstance",null),(0,o.Z)(this,"status",r.MP.NOT_READY),(0,o.Z)(this,"currentChainNamespace",r.EN.EIP155),(0,o.Z)(this,"openloginOptions",void 0),(0,o.Z)(this,"loginSettings",{loginProvider:""}),(0,o.Z)(this,"privKeyProvider",null),this.setAdapterSettings(p(p({},i.adapterSettings),{},{chainConfig:i.chainConfig,clientId:i.clientId||"",sessionTime:i.sessionTime,web3AuthNetwork:i.web3AuthNetwork,useCoreKitKey:i.useCoreKitKey})),this.loginSettings=i.loginSettings||{loginProvider:""}}}}}]);